import proguard.gradle.ProGuardTask

buildscript {
    repositories {
        maven {
            name = 'aliyun'
            url = 'https://maven.aliyun.com/repository/public'
        }
//        maven {
//            name = 'lss233'
//            url = 'https://www.lss233.com/artifactory/minecraft'
//        }
        maven {
            name = "forge"
            url = "http://files.minecraftforge.net/maven"
        }
    }
    dependencies {
        classpath 'net.minecraftforge.gradle:ForgeGradle:1.2-SNAPSHOT'
        classpath 'net.sf.proguard:proguard-gradle:6.0.3'
    }
}

apply plugin: 'forge'

version = "1.7.10-4.10.4"
group = "com.flansmod"

sourceCompatibility = targetCompatibility = 1.7

minecraft {
    version = "1.7.10-10.13.4.1614-1.7.10"
    runDir = "build/run"
}

processResources {
    inputs.property "version", project.version
    inputs.property "mcversion", project.minecraft.version
    from(sourceSets.main.resources.srcDirs) {
        include 'mcmod.info'
        expand 'version': project.version, 'mcversion': project.minecraft.version
    }
    from(sourceSets.main.resources.srcDirs) {
        exclude 'mcmod.info'
    }
}

tasks.withType(JavaCompile) {
    options.encoding = 'UTF-8'
}

// Define a ProGuard task.
task('proguard', type: ProGuardTask) {

    // You should probably import a more compact ProGuard-style configuration
    // file for all static settings, but we're specifying them all here, for
    // the sake of the example.
    //configuration 'configuration.pro'

    // Specify the input jars, output jars, and library jars.
    // In this case, the input jar is the program library that we want to process.

    injars 'build/libs/' + project.name + '-' + project.version + '.jar'
    outjars 'build/libs/' + project.name + '-' + project.version + '-obf.jar'

    // Automatically handle the Java version of this build.
    if (System.getProperty('java.version').startsWith('1.')) {
        // Before Java 9, the runtime classes were packaged in a single jar file.
        libraryjars "${System.getProperty('java.home')}/lib/rt.jar"
    } else {
        // As of Java 9, the runtime classes are packaged in modular jmod files.
        libraryjars "${System.getProperty('java.home')}/jmods/java.base.jmod", jarfilter: '!**.jar', filter: '!module-info.class'
        //libraryjars "${System.getProperty('java.home')}/jmods/....."
    }

    //libraryjars 'lib/forge-1.7.10-10.13.4.1614-1.7.10-srg.jar'
    ///libraryjars 'lib/forgeSrc-1.7.10-10.13.4.1614-1.7.10.jar'
    libraryjars 'lib/lwjgl-2.9.1.jar'
    libraryjars 'lib/netty-all-4.0.10.Final.jar'
    libraryjars 'lib/authlib-1.5.16.jar'
    libraryjars 'lib/log4j-core-2.0-beta9.jar'
    libraryjars 'lib/log4j-api-2.0-beta9.jar'
    libraryjars 'lib/guava-17.0.jar'
    //libraryjars 'lib/minecraft_srg_forge-1.7.10.jar.patched.jar'
    libraryjars 'lib/ForgeMod-1.7.10.jar'
    //libraryjars 'lib/'

    // Save the obfuscation mapping to a file, so we can de-obfuscate any stack
    // traces later on. Keep a fixed source file attribute and all line number
    // tables to get line numbers in the stack traces.
    // You can comment this out if you're not interested in stack traces.

    printmapping 'out.map'
    //keepparameternames
    renamesourcefileattribute 'SourceFile'
    keepattributes 'Exceptions,InnerClasses,Signature,Deprecated,'
    //SourceFile; LineNumberTable; EnclosingMethod

    // Preserve all annotations.

    keepattributes '*Annotation*'

    // Preserve all public classes, and their public and protected fields and
    // methods.

    keep 'public class * { \
        public protected *; \
    }'

    // Preserve all .class method names.

    keepclassmembernames 'class * { \
        java.lang.Class class$(java.lang.String); \
        java.lang.Class class$(java.lang.String, boolean); \
    }'

    // Preserve all native method names and the names of their classes.

    keepclasseswithmembernames 'class * { \
        native <methods>; \
    }'

    // Preserve the special static methods that are required in all enumeration
    // classes.

    keepclassmembers allowoptimization: true, 'enum * { \
        public static **[] values(); \
        public static ** valueOf(java.lang.String); \
    }'

    // Explicitly preserve all serialization members. The Serializable interface
    // is only a marker interface, so it wouldn't save them.
    // You can comment this out if your library doesn't use serialization.
    // If your code contains serializable classes that have to be backward
    // compatible, please refer to the manual.

    keepclassmembers 'class * implements java.io.Serializable { \
        static final long serialVersionUID; \
        static final java.io.ObjectStreamField[] serialPersistentFields; \
        private void writeObject(java.io.ObjectOutputStream); \
        private void readObject(java.io.ObjectInputStream); \
        java.lang.Object writeReplace(); \
        java.lang.Object readResolve(); \
    }'

    // Your library may contain more items that need to be preserved;
    // typically classes that are dynamically created using Class.forName:

    // keep 'public class com.example.MyClass'
    // keep 'public interface com.example.MyInterface'
    // keep 'public class * implements com.example.MyInterface'

    keep 'class net.** { *; }'
    
}
